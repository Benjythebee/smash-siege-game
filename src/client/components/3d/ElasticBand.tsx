/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 ./public/models/elastic.glb -t 
*/

import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';
import React, { useEffect, useRef } from 'react';
import { currentAmmoPosition } from '../../store.js';
import { create } from 'zustand';
import { onSlingshotLoadingObservable, onSlingshotReleaseObservable } from '../../observables.js';

const vertexShader = `
uniform float uTime;
uniform float uDragReleaseTime;
uniform float uDragRelease;
uniform vec3 uDragStart;
uniform vec3 uDragTarget;
uniform float uHalfWidth;

varying float vDistortion;

void main() {
    float startToTarget = distance(uDragTarget, uDragStart);
    float distanceToStart = distance(position, uDragStart);


    // Convert position to world space to take rotation into account
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vec3 worldPos = worldPosition.xyz;

    // Calculate world space distances
    float worldDistanceToStart = distance(worldPos, uDragStart);
    float worldStartToTarget = distance(uDragTarget, uDragStart);

    float slope =worldStartToTarget/uHalfWidth;
    
    if(uDragRelease > 0.) {
        float timeSinceRelease = uTime - uDragReleaseTime;
        slope *= exp(-3. * timeSinceRelease);
        slope *= sin(timeSinceRelease * 50.);
    }

    vec3 stretch = (uDragTarget - uDragStart) * slope * 0.5;
    float newPosZ = -abs(position.x)*slope;

    vec3 pos = position;

    // Ensure that points A and B remain fixed
    if (position.x <= (-uHalfWidth+0.1) || position.x >= (uHalfWidth-0.1)) {
        pos.z = 0.0;
    }else{
        pos += stretch;
        pos.z += newPosZ;
    }
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);

    vDistortion = slope;
}

`;

const fragmentShader = `
    varying float vDistortion;

    void main() {
        // Set a basic color for the elastic band
        gl_FragColor = vec4(vDistortion, 0., 0., 1.);
    }
`;

const releaseTimeStore = create<number>(() => 0);

export function ElasticBand(props: JSX.IntrinsicElements['group'] & { container: THREE.Group; pointA?: THREE.Vector3 }) {
  const { position, container, ...rest } = props;
  const mesh = useRef<THREE.Mesh>(null);

  const geometryRef = React.useRef<THREE.PlaneGeometry>(null!);
  const materialRef = React.useRef<THREE.ShaderMaterial>(null!);

  useFrame(({ clock }) => {
    releaseTimeStore.setState((t) => t + 0.01633);
    materialRef.current.uniforms.uTime.value = clock.getElapsedTime();
    materialRef.current.uniforms.uDragStart.value.copy(position);
    const ammoPosition = currentAmmoPosition().clone();
    // undo quaternion rotation
    if (container) {
      ammoPosition.applyQuaternion(container.quaternion.clone().invert());
    }
    materialRef.current.uniforms.uDragTarget.value.copy(ammoPosition);
  });

  useEffect(() => {
    const onSlingshotRelease = () => {
      materialRef.current.uniforms.uDragReleaseTime.value = releaseTimeStore.getState();
      materialRef.current.uniforms.uDragRelease.value = 1.0;
    };

    const onSlingshotLoading = () => {
      materialRef.current.uniforms.uDragRelease.value = 0.0;
    };

    const loadingObserver = onSlingshotLoadingObservable.add(onSlingshotLoading);
    const observer = onSlingshotReleaseObservable.add(onSlingshotRelease);
    return () => {
      onSlingshotLoadingObservable.remove(loadingObserver);
      onSlingshotReleaseObservable.remove(observer);
    };
  }, []);

  const ammoPos = currentAmmoPosition();
  const isZero = ammoPos?.equals(new THREE.Vector3(0, 0, 0));

  return (
    <group {...rest} position={position} dispose={null}>
      <mesh ref={mesh} name="elastic">
        <planeGeometry args={[3.7, 0.5, 100, 100]} ref={geometryRef} />
        {/* <meshBasicMaterial color="red" /> */}
        <shaderMaterial
          // attach="material"
          ref={materialRef}
          side={THREE.DoubleSide}
          args={[
            {
              uniforms: {
                uTime: { value: 0.0 },
                uDragReleaseTime: { value: 0.0 },
                uDragRelease: { value: 0.0 },
                uDragStart: { value: position || new THREE.Vector3(0, 0, 0) },
                uDragTarget: { value: !isZero ? currentAmmoPosition() : position || new THREE.Vector3(0, 0, 0) },
                uHalfWidth: { value: 1.85 }
              },
              vertexShader,
              fragmentShader
            }
          ]}
        />
      </mesh>
    </group>
  );
}

// useGLTF.preload('./models/elastic.glb');
